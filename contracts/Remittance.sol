pragma solidity ^0.4.24;

import "./Pausible.sol";

/*
Remittance contract. 
*/
contract Remittance is Pausible {

    event MoneySent(address sender, uint amount);
    event MoneyWithdrawnBy(address receiver, uint amount);
    event ContractCreated(address owner);
    event MoneyClaimedBack(address originalSender);
    
    uint constant public maxDaysClaimBack = 30;   

    struct RemittanceData {
        uint balance;
        uint deadline;
    }

    /**
     * Mapping of the result of Keccak256(Carol, passwordCarol, passwordBob) to 
     * the remittance data. This Keccak256 hash will be generated outside of
     * the contract by Alice based on the account address of Carol and 
     * both passwords. 
     **/
    mapping(bytes32 => RemittanceData) public remittances;

    /** Mapping of the hash of Alice's address and an remittance hash
     * that she generated when she sent the money. When claiming back the money, 
     * Alice shouldn't have to provide both passwords again as it would only verify 
     * that she hasn't forgotten the passwords. Just calling the claimback 
     * function with the remittance hash (and implicitly her address)
     * should be enough to give her back the funds. 
     **/
    mapping(bytes32 => bytes32) public claimbacks;

    /**
     * This constructor creates an instance of the Remittance contract.  
     **/
    constructor() public {
        emit ContractCreated(owner);
    }

    /**
     * This function sends money to the remittance contract. It accept the
     * remittance hash that Alice must generate outside of the contract. 
     * This hash will be generated by the applicaton that calls this function.
     **/
    function sendMoney(
            bytes32 remittanceHash, uint daysClaim)  
            public payable 
            onlyWhenActive {
                
        require(daysClaim <= maxDaysClaimBack && daysClaim > 0, 
            "Days claim back must be between 1 and 30");
        require(msg.value > 0, "Value sent must be greater than 0");
        require(remittanceHash != 0x0 && remittances[remittanceHash].balance == 0x0, 
            "Remittance hash already used (Choose other passwords) or in use or incorrect remittance hash");
        bytes32 claimbackHash = getKeccak256ForClaimback(remittanceHash);
        require(claimbacks[claimbackHash] == 0x0, 
            "Remittance hash already used (Choose other passwords)"); 
        remittances[remittanceHash].balance = msg.value;
        remittances[remittanceHash].deadline = now + (24 * 60 * 60 * daysClaim);
        claimbacks[claimbackHash] = remittanceHash;
        emit MoneySent(msg.sender, msg.value);

    }

    /**
     * Function that allows Carol to withdraw the balance in the remittance 
     * contract. Carol has to provide both her own password and the password 
     * that Bob gave to her. It's OK for both passwords to be visible on the
     * blockchain by other people, even if the transaction might not have 
     * been mined. Because only Carol can withdraw the funds because her address
     * is mixed with the passwords when calling the keccak256 function. Neither Bob
     * Alice or anybody else could snatch the funds before she could.
     **/
    function withdraw(string passwordCarol, string passwordBob) 
            public payable
            onlyWhenActive {

        bytes32 remittanceHash = 
            getKeccak256ForWithdrawal(passwordCarol, passwordBob);
        require(remittances[remittanceHash].balance != 0x0, 
            "Combination of passwords is not correct or no balance");
        uint availableBalance = remittances[remittanceHash].balance;
        remittances[remittanceHash].balance = 0;
        emit MoneyWithdrawnBy(msg.sender, availableBalance);
        msg.sender.transfer(availableBalance);
        
    } 
 
    /**
     * Carol can claim back the funds before Carol has withdrawn it. Alice only
     * needs to provide the the remittance. 
     **/
    function claimBack(bytes32 remittanceHash) public payable onlyWhenActive {
        
        bytes32 claimbackHash = getKeccak256ForClaimback(remittanceHash);
        require(claimbacks[claimbackHash] != 0x0, 
            "Combination of id and address not correct or already claimed back");
        require(remittances[remittanceHash].balance != 0x0, 
            "Remittance not accessible"); // Hack or appplication error ?
        require(now <= remittances[remittanceHash].deadline, 
            "Deadline reached, funds not claimed back");
        uint availableBalance = remittances[remittanceHash].balance;
        remittances[remittanceHash].balance = 0;
        claimbacks[claimbackHash] = 0x0;
        emit MoneyClaimedBack(msg.sender);
        msg.sender.transfer(availableBalance);
        
    }
    
    /**
     * Fallback function which shouldn't be used to send money to the contract,
     * so don't make it payable
     **/
    function() public {
        revert("Not implemented");
    }
    
    function getKeccak256ForWithdrawal(
        string passwordCarol, string passwordBob) 
        view public
        returns (bytes32) {
        return keccak256(abi.encodePacked(passwordCarol, passwordBob, msg.sender));        
    }

    function getKeccak256ForClaimback(bytes32 remittanceHash) 
        view public
        returns (bytes32) {
        return keccak256(abi.encodePacked(msg.sender, remittanceHash));        
    }

}